# Esperanto-Kanji-Converter-and-Ruby-Annotation-Tool-Russian

---
Ниже представлен **подробный русскоязычный мануал** по использованию приложения Streamlit для замены текста в эсперанто (и дополнения руби/иероглифов), предназначенный для **русскоязычных GUI-пользователей**. Инструкция опирается на четыре Python-файла, из которых состоит приложение:

1. **`main.py`** (основной файл приложения Streamlit)  
2. **`Генератор JSON-файлов (замена иероглифов в эсперанто-тексте).py`** (в папке `pages/` — отдельная страница, где можно сформировать JSON)  
3. **`esp_text_replacement_module.py`** (модуль с основными функциями замены, placeholders, параллелизмом)  
4. **`esp_replacement_json_make_module.py`** (модуль с функциями для генерации/соединения правил замены, сборки большого JSON и т.д.)

Ниже шаг за шагом объясняется, как настроить и использовать это приложение.

---

## 1. Основная логика и структура приложения

### 1.1. Поток работы (общая схема)

1. **(Необязательно) Создать/собрать JSON для замены**  
   - Переход на страницу (2) – “Генератор JSON-файлов…”  
   - Загрузить (или использовать по умолчанию) CSV-файл, описывающий сопоставление корня эсперанто и нужного перевода (иероглифы / русский текст).  
   - (Необязательно) Загрузить JSON-файлы, задающие особые правила разбора корней, приоритетов, пользовательских строк замены и т.д.  
   - Нажать кнопку “Создать JSON-файл для замены”.  
   - Скачать итоговый JSON (примерно 50 МБ) с тремя основными списками:  
     1) Глобальные правила замены (`replacements_final_list`)  
     2) Локальные правила (только для `@...@`)  
     3) Правила для “двухбуквенных корней” (префиксы/суффиксы и пр.).

2. **На главной странице (1) `main.py`**  
   - Либо используйте уже имеющийся (сгенерированный) JSON, либо “дефолтный” JSON.  
   - Задайте формат вывода (HTML с руби? Скобки? Только подстановка?).  
   - Введите текст — вручную или загружая файл.  
   - Укажите, нужно ли **использовать параллельную обработку** (в случае больших текстов).  
   - Нажмите “Отправить” (или аналогичную кнопку). Приложение выполнит замену.  
   - Результат можно смотреть в виде **HTML-превью** (вкладка “HTML-просмотр”) и/или текстом, также можно сохранить (“Скачать результат…”).

---

## 2. Подробности каждого файла/страницы

### 2.1. `main.py` (Главная страница приложения Streamlit)

- **`st.set_page_config(...)`** — устанавливает заголовок вкладки браузера и широкую верстку.  
- **Чтение JSON**  
  - Радиокнопка: “Использовать JSON по умолчанию” / “Загрузить JSON”.  
  - Если загружен, приложение читает JSON и извлекает три списка замены (глобальный, локальный, 2-буквенный).  
- **Импорт placeholders**  
  - `placeholders_for_skipping_replacements` — строки, защищающие `%...%`.  
  - `placeholders_for_localized_replacement` — для `@...@`.  
- **Настройка параллелизма**: чекбокс “Использовать параллельную обработку”, выбор числа процессов.  
- **Выбор формата вывода** (HTML / скобки / простой)  
- **Ввод эсперанто-текста**: либо вручную в `st.text_area`, либо через `st.file_uploader`.  
- **Кнопка “Отправить”**:
  1. Если параллель → вызывает `parallel_process(...)`. Иначе → `orchestrate_comprehensive_esperanto_text_replacement(...)`.  
  2. Осуществляется логика с `%...%` и `@...@`, затем глобальные списки замены, затем 2-буквенные корни.  
  3. Преобразует эсперанто-символы (например, `cx` → `ĉ` или `c^`) в соответствии с выбранным режимом.  
  4. Применяется стилизация HTML-рубИ, если нужно.  

- **Результат**: Отображается либо вкладка с HTML, либо чистый текст. Ограничивается 250 строками для предпросмотра. Можно скачать результат .html.

#### Важные моменты

- **`@st.cache_data`**: при загрузке JSON больших размеров (до ~50МБ) кеширование ускоряет чтение.  
- **`placeholders`**: благодаря “old → placeholder → new” мы избегаем конфликтов при повторных заменах и защищаем сегменты `%...%` / `@...@`.  
- **Сокращенное отображение**: длинный текст обрезается, чтобы интерфейс не зависал.

---

### 2.2. `Генератор JSON-файлов…py` (pages/…)

- На отдельной странице (доступной через меню “Pages” в Streamlit Cloud) — **создание большого JSON**.  
- **CSV** (корни эсперанто → иероглифы/русский перевод).  
- **JSON** (настройки разбора корней: глагольные окончания, приоритеты, -1 для исключения и пр.).  
- При желании — “пользовательский” JSON, где для конкретного слова прописаны особые символы.  
- Нажимаем кнопку “Создать JSON-файл для замены” → внутри кода:

  1. Читает “PEJVO(…)” (огромный список) + “~11137 корней эсперанто”.  
  2. Сопоставляет с CSV, расставляет placeholder.  
  3. (Необязательно) Применяет логику “двигать приоритет, если слово заканчивается на an/on, если это глагол с as/is/os и т.д.”  
  4. Сливает с пользовательскими настройками, если есть (`custom_stemming_setting_list` / `user_replacement_item_setting_list`).  
  5. В итоге формируются три массива:  
     - `replacements_final_list` (глобальный)  
     - `replacements_list_for_2char` (двухбуквенные корни, напр. `$ar`, `$am`)  
     - `replacements_list_for_localized_string` (локальная замена для `@...@`).  
- **Скачиваем** “Итоговый_список_замены.json”. Впоследствии подгружаем его в `main.py`.

---

### 2.3. `esp_text_replacement_module.py`

- Основной движок замены:

  - **`orchestrate_comprehensive_esperanto_text_replacement(...)`**  
    1) Нормализация пробелов, 2) `cx`/`c^` в `ĉ`,  
    3) `%...%` → пропуск,  
    4) `@...@` → локальная замена,  
    5) глобальная замена,  
    6) двукратная замена 2-буквенных корней,  
    7) возврат placeholders,  
    8) если формат HTML — `\n` → `<br>`, пробелы → `&nbsp;`, и т.п.

  - **`parallel_process(...)`** разбивает текст на строки и делает параллельный вызов к `process_segment(...)`.  

  - **`safe_replace(...)`** — логика “old→placeholder→new”, исключая повторные замены.

---

### 2.4. `esp_replacement_json_make_module.py`

- Функции, нужные при построении JSON:  
  - **`output_format(...)`**: как объединить “основной текст” и “руби/иероглиф” (HTML, скобки, etc.). Учитывает измерение ширины символов, автоматический `<br>` вставляется для длинного руби.  
  - **`parallel_build_pre_replacements_dict(...)`**: обрабатывает огромные списки (десятки тысяч слов) в параллельном режиме, применяя `safe_replace`.  
  - **`remove_redundant_ruby_if_identical(...)`**: если `<ruby>слово<rt>слово</rt></ruby>`, удаляет дублирование.  
  - И т.д.

---

## 3. Пошаговая инструкция для пользователя (GUI)

Допустим, вы хотите использовать приложение **только для подстановки** уже готового JSON:

1. **Перейти на главную страницу** (выполняется `main.py`).  
2. **В разделе “Что делать с JSON?”** нажать “Загрузить” и выбрать ваш `…(合并3个JSON文件).json`. Если не загружать — используется встроенный “по умолчанию”.  
3. **Выбрать формат вывода**: (например, “HTML формат (Ruby-символы, изменение размера)”).  
4. **Опционально**: задать “Использовать параллельную обработку” (если у вас большой текст).  
5. **Ввести текст** вручную (или загрузить `.txt`).  
   - Можно использовать `%...%` для игнорирования части текста при замене.  
   - Можно использовать `@...@` для локальной замены (особые правила).  
6. **Нажать “Отправить”**.  
   - Приложение выполнит все этапы замены.  
   - Результат появится на вкладках (HTML-просмотр / исходный код).  
7. **Скачать** результат (`.html`).  

Если же вы хотите **подготовить собственный JSON**, где будут новые пары (корень эсперанто → перевод), дополнительные правила:

1. **Зайти на страницу “Генератор JSON-файлов…”** (из меню Pages).  
2. **CSV-файл**: загрузить свой (две колонки: [корень, перевод]) или взять “дефолтный”.  
3. **JSON-файлы** (правила разбора, пользовательские строки замены) — тоже либо загрузить, либо использовать по умолчанию.  
4. **Нажать “Создать JSON-файл…”**. Пройдет некоторое время, пока весь словарь/правила соберутся.  
5. **Скачать** получившийся JSON.  
6. Далее вернуться в **главную страницу** и загрузить этот JSON в радио-кнопке “JSON для замены”.  

---

## 4. Особые примечания

1. **Параллельная обработка**  
   - В Streamlit иногда надо прописывать `multiprocessing.set_start_method("spawn")`. Это уже учтено в коде (в блоке `try/except`).  
   - Число процессов рекомендуют ~2…6. Сильный прирост будет на больших текстах.

2. **Шрифт и руби**  
   - По умолчанию приложение рассчитано на HTML-вывод. Для “Ruby” применяется стилизация `<ruby>…<rt>…</rt></ruby>` с динамической корректировкой размера.  
   - В браузере результат можно скачать и открыть локально. Поддержка Ruby-тегов зависит от браузера, но обычно Chrome/Firefox их отображают.

3. **CSV / JSON-форматы**  
   - CSV должен содержать хотя бы 2 колонки (корень, перевод).  
   - JSON имеет сложную структуру с тремя списками (глобальный, локальный, 2-буквенный). Модули внутри кода (`esp_replacement_json_make_module.py`) создают эти списки автоматически.

4. **Анализ коротких слов**  
   - Приложение особым образом трактует 2-буквенные корни (префиксы/суффиксы: `as`, `am`, `ek` и т.п.).  
   - При желании можно отключить часть этих правил, убирая их из JSON.

---

## 5. Заключение

Таким образом:

1. **“main.py”** — интерфейс для быстрой замены: загружаем JSON (или используем дефолт), указываем формат, вводим текст, получаем результат.  
2. **“Генератор JSON-файлов…”** — вспомогательная страница для больших кастомных таблиц соответствий, чтобы объединить CSV+доп. JSON в единый JSON-файл замены.  
3. **“esp_text_replacement_module.py”** — логика построчного/параллельного алгоритма, защита сегментов `%...%`, локальная замена `@...@`, функция “safe_replace”, и т.д.  
4. **“esp_replacement_json_make_module.py”** — вспомогательные функции при построении JSON: “output_format”, измерение ширины символов, обработка g^→ĝ и т.д.

**Надеемся**, что данная инструкция поможет русскоязычным пользователям успешно работать с приложением:  
- Грамотно настроить CSV,  
- При необходимости настроить правила (JSON),  
- Запустить “замену иероглифов/добавление руби” в тексте на эсперанто,  
- Получить аккуратно отформатированный результат (HTML / скобки / etc.).

Удачи в использовании инструмента! Если что-то пошло не так — смотрите логи в консоли Streamlit или проверяйте соответствие формата CSV/JSON требуемой структуре.  
