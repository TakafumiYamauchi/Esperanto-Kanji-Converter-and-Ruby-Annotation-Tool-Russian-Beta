# Esperanto-Kanji-Converter-and-Ruby-Annotation-Tool-Russian

Ниже представлена **подробная техническая инструкция**, которая ориентирована на **российских (русскоязычных) программистов среднего уровня**, уже знакомых с базовым использованием GUI в данном приложении, и желающих **глубже понять внутреннее устройство** (архитектуру, логику и взаимосвязь модулей) приложения Streamlit для замены текста на эсперанто (с добавлением иероглифов, руби-обозначений и т.д.).

---

## 1. Общий обзор структуры и назначения файлов

Приложение состоит из **4 основных файлов** на Python:

1. **`main.py`**  
   - Главный (центральный) файл Streamlit-приложения, запускаемый по умолчанию.  
   - Содержит UI (радиокнопки, кнопки, загрузчики файлов и т.д.), а также организацию общей логики замены.  
   - Отвечает за:
     - Загрузку и кеширование JSON (правил замены).  
     - Обработку пользовательского ввода (текста) и вызов соответствующих функций модуля `esp_text_replacement_module.py`.  
     - Параллельный режим (multiprocessing) и итоговый вывод результатов с возможностью скачивания.  

2. **`JSON File Generation Page for Esperanto Text (Kanji) Replacement.py`**  
   - Дополнительная страница (в каталоге `pages/`), которая позволяет **генерировать/собирать большой JSON** для замены.  
   - Содержит инструменты:
     - Загрузка CSV-файлов (корень эсперанто → перевод/иероглиф).  
     - Загрузка дополнительных JSON-файлов с пользовательскими настройками (разбор корней, приоритеты, исключения).  
     - Генерация единого JSON, где соединяются:
       1) Глобальные правила,  
       2) Правила для “двухбуквенных корней”,  
       3) Правила для “локальной” замены (только внутри `@…@`).  

3. **`esp_text_replacement_module.py`**  
   - Модуль, содержащий ключевые функции по **замене текста** (включая логику `%…%` для пропуска, `@…@` для локальной замены), а также параллельную обработку (разбиение на блоки и multiprocessing).  
   - В частности, основная функция:  
     **`orchestrate_comprehensive_esperanto_text_replacement(...)`** — в которой:
       - Сначала текст нормализуется (пробелы, символы эсперанто в “circumflex”-форме).  
       - Затем блоки `%…%` и `@…@` обрабатываются при помощи placeholders.  
       - Применяется глобальная замена (по большим спискам).  
       - Двухбуквенные корни заменяются дополнительно.  
       - В конце, при необходимости, HTML-формат дополняется `<br>` и `&nbsp;` и т.д.  
   - Логика параллельной обработки реализована через `multiprocessing.Pool`, где каждая часть текста (например, разбитая по строкам) обрабатывается той же функцией `orchestrate…`, но в разных процессах.  

4. **`esp_replacement_json_make_module.py`**  
   - Модуль, используемый в основном **на этапе формирования большого JSON**:  
     - Функции для измерения ширины строк (для `<ruby>`-тегов при очень длинных вспомогательных надписей).  
     - Форматирование “main_text / ruby_content” в разных стилях (HTML, скобки, простой) через функцию **`output_format(...)`**.  
     - Параллельные заготовки для «предобработки» больших словарей (где десятки тысяч корней).  
     - Логика “remove_redundant_ruby_if_identical(...)”, если `<ruby>abc<rt>abc</rt></ruby>`.  

Таким образом, файлы (3) и (4) являются своеобразными “библиотеками” с функциями, а файлы (1) и (2) — это **две разные страницы** (две entry points) в Streamlit-приложении.

---

## 2. Более детальный разбор каждого файла

### 2.1. `main.py`

#### 2.1.1. Настройка и кеширование JSON
В начале файла:

```python
@st.cache_data
def load_replacements_lists(json_path: str) -> Tuple[List, List, List]:
    ...
```
- Используется `@st.cache_data` (Streamlit) для того, чтобы загружать большой JSON (до ~50 МБ) в кеш и не пересчитывать при каждом обновлении страницы.  
- Возвращается кортеж из трёх основных списков:  
  1) `replacements_final_list` — глобальные замены,  
  2) `replacements_list_for_localized_string` — для “локальной” замены внутри `@...@`,  
  3) `replacements_list_for_2char` — для двухсимвольных корней (например, `$am`, `$ar`).  

#### 2.1.2. Выбор формата, загрузка JSON, placeholders
- В интерфейсе Streamlit (`st.radio`, `st.file_uploader`) юзер выбирает: “Использовать JSON по умолчанию” или “Загрузить”.  
- Если юзер загружает, то JSON читается через `json.load` → инициализируются списки замены.  
- Параллельно загружаются **placeholders** для:  
  - `%...%` (пропуск)  
  - `@...@` (локальная замена)  

#### 2.1.3. Параллелизм (multiprocessing)
- В `main.py` есть чекбокс “Использовать параллельную обработку” и `number_input` для кол-ва процессов.  
- Если включено, при нажатии “Отправить” вызывается `parallel_process(...)` из `esp_text_replacement_module.py`, иначе — однопоточная версия.

#### 2.1.4. Ввод текста
- Можно ввести вручную (`st.text_area`) или загрузить файл (`st.file_uploader`).  
- В случае загрузки файла — декодируется в UTF-8.

#### 2.1.5. Основной вызов замены
При нажатии “Отправить”:
1. Сохраняет `text0` в `st.session_state`, чтобы при перезагрузке не потерялось.  
2. Вызов `parallel_process(...)` или `orchestrate_comprehensive_esperanto_text_replacement(...)`.  
3. В конце — учитывается “режим вывода символов эсперанто”:
   - “Надстрочные знаки” (эквивалентно сначала всё переводить в `cx`, потом `cx` → `ĉ`?),  
   - “x-формат”,  
   - “^-формат”.  

#### 2.1.6. Вывод (HTML-превью, ограничение 250 строк, кнопка “Скачать”)
- Если формат “HTML”, то создаются две вкладки:
  - `HTML-просмотр` (`components.html(...)`)  
  - Исходник (text_area).  
- Иначе просто вывод text_area с результатом.  
- Предусмотрено ограничение вывода (250 строк) для случаев гигантских текстов.  

---

### 2.2. `JSON File Generation Page for Esperanto Text (Kanji) Replacement.py`

Это отдельная страница Streamlit (лежит в папке `pages/`), которая **не используется** при повседневной замене, но **нужна**, если вы хотите **собрать свой большой JSON**.

#### 2.2.1. Загрузка CSV, JSON
- Интерфейс предлагает:
  1) Загрузить CSV (пары корень эсперанто → перевод/иероглиф).  
  2) Загрузить (опционально) JSON с дополнительными правилами (`custom_stemming_setting_list` и `user_replacement_item_setting_list`).  
  3) Выбрать формат (HTML-рубИ / скобки / простой текст).

#### 2.2.2. Создание списка замен
- Внутри кнопки “Создать JSON” запускается большой код, который:
  - Читает огромный список корней (PEJVO…), “~11137 корней”.  
  - Корректирует приоритет замены, добавляет глагольные окончания (as, is, os…), обрабатывает `an`, `on`.  
  - Для двухбуквенных корней (am, ar и т.п.) создает отдельный список, используя placeholders `$am`, `$ar`.  
  - (Опционально) применяет пользовательские JSON (где может быть “-1” для исключения слова или особая разметка).  

#### 2.2.3. Итоговое объединение
- Формируется **3 списка**:  
  1) `replacements_final_list` (основной глобальный),  
  2) `replacements_list_for_2char`,  
  3) `replacements_list_for_localized_string` (для `@...@`).  
- Сохраняется в JSON. Этот JSON потом передается в `main.py`.

---

### 2.3. `esp_text_replacement_module.py`

Здесь основной механизм замены. Ключевые элементы:

1. **Словари для преобразования эсперанто-символов**:
   - `x_to_circumflex`, `hat_to_circumflex` и т.д. (cx → ĉ, c^ → ĉ…).  
2. **Функция `orchestrate_comprehensive_esperanto_text_replacement(text, ...)`**:
   - **Шаги**:
     1. `unify_halfwidth_spaces` (замена \u00A0, \u2002 и т.п. на обычный пробел).  
     2. `convert_to_circumflex` (приведение входа к “ĉ, ĝ, ĥ” и т.д.).  
     3. Обработка `%...%`:  
        - Находит все куски, оборачивает в placeholders, чтобы пропустить глобальную замену.  
     4. Обработка `@...@`:  
        - Аналогично, но внутри этих кусков применяется локальная замена (`replacements_list_for_localized_string`).  
     5. **Глобальная замена** (`replacements_final_list`):  
        - Все пары (old, new, placeholder), происходит “old → placeholder → new” (через `safe_replace`).  
     6. **2-буквенные корни** (два раза, т.к. иногда нужно повторить).  
     7. Восстановление placeholders для `%...%` и `@...@`.  
     8. Если формат “HTML”, то заменяем `\n` на `<br>` и множественные пробелы на `&nbsp;`.  
   - В итоге возвращается уже замененный текст.

3. **Функции для параллелизма**:
   - `parallel_process(text, num_processes, ...)`, которая:
     - Делит текст на строки.  
     - Распределяет диапазоны строк по пулам процессов (`multiprocessing.Pool`).  
     - Каждый процесс вызывает `process_segment(...)`, которая внутри применяет `orchestrate_comprehensive_esperanto_text_replacement(...)`.  
     - Сшивает результат.  

---

### 2.4. `esp_replacement_json_make_module.py`

Здесь собраны функции, нужные в основном при построении/генерации JSON, но некоторые могут быть задействованы и в `main.py`.

- **`replace_esperanto_chars`, `convert_to_circumflex`** — дублируют идею из `esp_text_replacement_module.py`.  
- **`measure_text_width_Arial16`, `insert_br_at_half_width`, `insert_br_at_third_width`** — инструменты для точного вычисления ширины строк (при генерации HTML-рубИ, когда “верхняя часть” может быть длиннее “основной”).  
- **`output_format(main_text, ruby_content, format_type, char_widths_dict)`**:  
  - Ядро логики соединения: <ruby>main<rt>ruby</rt></ruby> или `main(ruby)` и т.д.  
  - Если “HTML формат (Ruby-символы, изменение размера)”, то специально вычисляет “отношение ширин” для оптимального вывода.  
- **`process_chunk_for_pre_replacements`, `parallel_build_pre_replacements_dict`** — аналогичны: chunk’и данных обрабатывают safe_replace.  
- **`remove_redundant_ruby_if_identical(text)`**:  
  - Например, если получилось `<ruby>test<rt>test</rt></ruby>`, удаляем ruby, потому что основной текст = rubi.

---

## 3. Глубокие аспекты внутренней логики

1. **Placeholders**  
   - Почему используется механизм “old → placeholder → new”, а не просто “text.replace(old, new)”?  
     - Если мы делаем простую замену, может происходить конфликт, когда “new” частично совпадает со “старым” и т.п.  
     - Через placeholder цепочка выглядит:
       1) text.replace(old, placeholder),  
       2) затем text.replace(placeholder, new).  
     - Так гарантируется, что **не будет повторного поиска** “old” внутри уже замененного фрагмента.

2. **Обработка `%...%`**  
   - `%…%` — сегменты, которые должны остаться без изменений.  
   - Для этого создается список: `[("%текст%", placeholderN), ...]`.  
   - Сначала всё в этих границах заменяется на placeholderN, а в конце восстанавливается исходник.  

3. **Обработка `@...@`**  
   - Напротив, `@…@` — куски, к которым применяется “локальная” (специальная) замена.  
   - Делается `safe_replace` для внутренностей.  
   - Потом тоже placeholders, чтобы избежать глобальной замены снаружи.

4. **Параллельная обработка**  
   - В больших текстах (десятки тысяч строк) параллелизм полезен.  
   - Одно “узкое место”: обычно multiprocessing требует, чтобы все объекты были сериализуемы (Pickle). Поэтому `set_start_method("spawn")` важен.  
   - В `main.py` есть try/except: `multiprocessing.set_start_method("spawn")`. Если уже установлено, пропускается.

5. **Двухбуквенные корни**  
   - В эсперанто множество 2-буквенных морфем (ar, am, ek, as).  
   - Если эти 2 буквы попадают в более длинные слова, иногда они должны заменяться отдельно.  
   - Для этого в JSON есть `replacements_list_for_2char`, содержащий, например, (“$ar”, “$<ruby>ar<rt>…</rt></ruby>”).  
   - При обработке (2 раза подряд) некоторые особые случаи “собираются” правильно.

6. **Приоритеты замены**  
   - В генераторе JSON (страница 2) много логики: “(i, j[0], j[1])” и т.д., назначается “replacement_priority_by_length”, чтобы слова большей длины заменялись в первую очередь.  
   - Это даёт избежать столкновений, когда “kanto” и “kant” пересекаются.

---

## 4. Типичный рабочий процесс “под капотом”

Если пользователь загрузил текст:  
1. Строка (допустим, `"Estas %не трогать% la @speciala@ teksto"`).  
2. `unify_halfwidth_spaces` — лишние юникод-пробелы заменяются на ASCII 0x20.  
3. `convert_to_circumflex` — если пользователь указал, что вход может содержать `cx`, → приводит к `ĉ`.  
4. `create_replacements_list_for_intact_parts` для `%не трогать%`, получается placeholder `%…%` → `PH_1`.  
5. `create_replacements_list_for_localized_replacement` для `@speciala@`, → `PH_2`. Но внутри `@speciala@` применяется список “локальных” замен (если `speciala` есть в словаре).  
6. Применяется глобальная замена (например, “estas” → `<ruby>est<rt>быть</rt></ruby>as”…`).  
7. Двухбуквенные корни (если есть “as”, “al”, “am”). Меняются placeholders `$as`, `$am`.  
8. Восстанавливаются `PH_2` → заменённый “@…@”-фрагмент, и `PH_1` → “не трогать” без изменений.  
9. Конверсия (если нужен “^ формат” или “x формат”).  
10. `apply_ruby_html_header_and_footer`, если выбрана HTML-версия.

---

## 5. Резюме для “среднего программиста”, где какие вызовы делать

- **Генерация JSON**:  
  - При необходимости, если хотим расширить словарь, сами правим CSV/JSON.  
  - Заходим в (2) “JSON File Generation Page…”, грузим, скачиваем итог.

- **Выполнение замены**:  
  - `main.py` читает наш JSON, placeholders, задаём формат — всё происходит автоматически через `orchestrate_comprehensive_esperanto_text_replacement(...)`.

- **Если нужно углубиться**:  
  - Посмотреть код `esp_text_replacement_module.py` — там описаны конкретные Regex, механизмы поиска `@(.{1,18}?)@` / `%(.*?)%`, структура “placeholder”.  
  - В `esp_replacement_json_make_module.py` — детали вычислений ширины символов (в `Unicode_BMP全范围文字幅(宽)_Arial16.json`) и “rubify” (необычные CSS-классы `XXXS_S`, `XXS_S` и т.д.).  

---

## 6. Заключение

Этот проект — достаточно сложное Streamlit-приложение, которое:

- Позволяет **гибко собирать** огромные таблицы замен (через CSV+JSON).  
- **Применяет** их параллельно (multiprocessing) к любому “эсперанто”-тексту, с сохранением частей `%…%` и особым разбором `@…@`.  
- Даёт богатые возможности форматирования (HTML, скобки, простой).  

Для русского программиста, уже знакомого с тем, как пользоваться Streamlit GUI, эта инструкция даёт понимание **“внутренней кухни”**:

1. Как загружаются и кешируются JSON и placeholders.  
2. Каким образом устроена параллельная обработка и зачем нужен “spawn”.  
3. Чем отличаются глобальные/локальные/двухбуквенные списки замен.  
4. Как устроена генерация JSON на дополнительной странице (2).  

Таким образом, можно **вносить правки** (напр., в `esp_text_replacement_module.py` для особого Regex) или **дополнять** код (напр., новый формат вывода), зная, где именно прописана нужная логика.
