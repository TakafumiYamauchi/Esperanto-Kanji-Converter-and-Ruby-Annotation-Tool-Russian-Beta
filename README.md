# Esperanto-Kanji-Converter-and-Ruby-Annotation-Tool-Russian

---
**Ниже приведено подробное руководство по работе с приложением на Streamlit (рассчитанным на русскоязычных пользователей), которое состоит из четырех основных частей (файлов)**:
1. **`main.py`** – главный файл приложения, где находится основная логика замены иероглифов/слов в эсперанто-тексте и аннотирования (руби).
2. **`JГенератор JSON-файлов для замены (иероглифов) в эсперанто-тексте.py`** – вторая страница приложения (лежит в папке `pages/`), позволяющая генерировать собственные JSON-файлы правил замены.
3. **`esp_text_replacement_module.py`** – вспомогательный модуль, содержащий набор функций для выполнения основных операций замены/руби/предварительной обработки в главном приложении.
4. **`esp_replacement_json_make_module.py`** – второй вспомогательный модуль, который поддерживает логику генерации JSON-файлов (например, разбор корней, правила форматирования и т. д.).

Далее по шагам описано, **как русскоязычному пользователю** работать с этим приложением, какие элементы интерфейса (GUI) существуют и как ими пользоваться. Материал довольно обширный, поэтому он разбит на несколько разделов:

---

## 1. Общая структура приложения и запуск
Приложение создано на базе **Streamlit**, поэтому при локальном запуске вам нужно:
1. Установить необходимые зависимости (библиотеки `streamlit`, `pandas`, `multiprocessing` и т.п.) в своё окружение Python.
2. Запустить в терминале (в папке, где лежит `main.py`):
   ```bash
   streamlit run main.py
   ```
3. По умолчанию в браузере откроется адрес `http://localhost:8501`, где вы увидите главный интерфейс приложения.

В **корневой директории** проекта лежит `main.py`, а в подпапке `pages/` вы найдёте второй скрипт — `JГенератор JSON-файлов для замены (иероглифов) в эсперанто-тексте.py`.  
Файлы `esp_text_replacement_module.py` и `esp_replacement_json_make_module.py` тоже должны находиться в доступе (импортируются из того же каталога).

---

## 2. Главная страница (`main.py`): функциональность и использование

Запустив `main.py`, вы увидите интерфейс со следующими основными блоками:

### 2.1 Выбор и загрузка JSON-файла с правилами замены
В верхней части страницы будет радиокнопка:
> **«Что делать с файлом JSON? (Загрузка JSON для замены)»**  
>  • «Использовать по умолчанию»  
>  • «Загрузить»  

- Если выбрать «Использовать по умолчанию», приложение возьмёт заранее подготовленный JSON (находящийся в папке `./Appの运行に使用する各类文件/…`) и автоматически загрузит правила.  
- Если выбрать «Загрузить», то появится кнопка для **загрузки собственного файла** (тип `.json`).  
  - Нажмите «Обзор» / «Browse» и выберите свой JSON-файл, где хранятся правила замены.  

В разделе ниже есть раскрывающийся блок (expander) **«Пример JSON (файл для замены)**», откуда, при желании, можно **скачать пример** JSON-файла, чтобы посмотреть его структуру.

#### Что за структура у JSON?
Этот JSON содержит три списка правил (каждый — список кортежей/массивов):
1. **`"全域替换用のリスト(列表)型配列(replacements_final_list)"`**  
   “Глобальные” правила замены: пара («старое», «новое», «служебная метка»).  
2. **`"局部文字替换用のリスト(列表)型配列(replacements_list_for_localized_string)"`**  
   “Локальные” правила замены: применяются только в частях текста, выделенных символами `@...@`.  
3. **`"二文字词根替换用のリスト(列表)型配列(replacements_list_for_2char)"`**  
   Правила специально для двухсимвольных корней и т. п.

В большинстве случаев достаточно загрузить один JSON, где все три списка объединены, — именно это делают настройки по умолчанию.

### 2.2 Механизм placeholders (placeholders_for_skipping_replacements)
Приложение автоматически подгружает внутри `main.py` ещё некоторые текстовые файлы (из папки `./Appの运行に使用する各类文件/…`), содержащие **списки placeholder-строк**, используемые для временной замены кусочков текста. Нужно это для того, чтобы:
- Не перезаписывать текст внутри `"%...%"` (пропуск замены)  
- Локально обрабатывать `@...@` (замена внутри только этих фрагментов)  

Пользователю, как правило, не нужно вдаваться в детали: достаточно знать, что **при желании** часть текста можно «защитить» от изменения, обрамив её символами `%...%`, или, напротив, **принудить** к особой локальной замене через `@...@`.

### 2.3 Настройки параллельной обработки (multiprocessing)
В блоке с заголовком **«Расширенные настройки (параллельная обработка)»**:
- **«Использовать параллельную обработку»** — флажок, чтобы включить или выключить multiprocessing (по умолчанию отключён).  
- **«Количество процессов»** — задаёт число потоков/процессов (от 2 до 4 в данном примере).  

Если у вас большой объём текста или сложные JSON-правила, **включение параллельной обработки** может ускорить замену, однако это зависит от структуры данных и возможностей CPU.

### 2.4 Выбор формата вывода (HTML / Скобки / и т. д.)
В выпадающем списке (selectbox) **«Выберите формат вывода…»** вы увидите такие варианты (примерно):
- **HTML формат (Ruby-символы, изменение размера)**  
- **HTML формат (Ruby-символы, изменение размера, замена иероглифов)**  
- **HTML формат**  
- **HTML формат (замена иероглифов)**  
- **Формат со скобками**  
- **Формат со скобками (замена иероглифов)**  
- **Только замененная строка (простая замена)**  

Смысл в том, как в конечном тексте будут сочетаться оригинальное слово и «руби»-подпись (или заменённый иероглиф + эсперанто).  
- Например, **«HTML формат (Ruby-символы, изменение размера)»** добавляет HTML-теги `<ruby>…<rt>…</rt></ruby>` и автоматически вычисляет размер руби-символов на основе длины оригинала. Это удобно, если вы хотите выводить текст в браузере с надстрочными значениями.  
- **«Формат со скобками»** просто даёт результат вида `main_text(ruby_part)`.  
- **«Только замененная строка (простая замена)»** полностью убирает исходную часть и оставляет только «перевод»/«иероглифы».  

Когда вы готовите свой JSON для замены, стоит придерживаться того же формата (чтобы логика замены соответствовала).

### 2.5 Ввод текста: ручной или из файла
Чуть ниже на странице видна секция:
> **«Источник входного текста»**  
>   - «Ввести вручную»  
>   - «Загрузить из файла»  

1. Если **«Ввести вручную»**:  
   Появится большое поле `text_area`, куда можно напрямую вписать нужный эсперанто-текст (включая любые символы).  
   - Можно использовать символы `%…%` для защиты фрагмента от замены.  
   - Можно использовать символы `@…@` для локальной замены.  
2. Если **«Загрузить из файла»**:  
   - Выберите `.txt`, `.csv` или `.md` файл (UTF-8) с текстом, и он будет считан.  
   - Загруженный текст отобразится в многострочном поле, чтобы при необходимости вы могли подредактировать его вручную.  

### 2.6 Кнопки «Отправить» и «Отмена»
В **форме** (область `st.form`) есть две кнопки:
- **«Отправить»** — по нажатию запускается логика замены, учитывая:
  1) Выбранные / загруженные JSON-правила  
  2) Настройки параллельности  
  3) Формат вывода  
  4) % … % / @ … @  
  5) Выбранную систему диакритики (nadstrochnye znaki, x-формат, ^-формат)  
- **«Отмена»** — прерывает процесс, не делая замен.  

### 2.7 Система диакритики (выбор «Надстрочные диакритические знаки», «x-формат» или «^-формат»)
Под полем ввода эсперанто-текста есть радиокнопка:  
> **«Формат выходных символов»**  
>   - «Надстрочные диакритические знаки» (`ĉ, ĝ, ĵ …`)  
>   - «x-формат» (`cx, gx, jx …`)  
>   - «^-формат» (`c^, g^, j^ …`)  

Укажите, в каком стиле следует отобразить буквы «ĉ, ĝ, ĥ, ĵ, ŝ, ŭ» в результате.  
- Если выбрать «Надстрочные диакритические знаки» — всё будет в виде истинных символов Юникода (`ĉ, ĝ, ŝ, …`).  
- «x-формат» — классический способ писать эсперанто без диакритики (`cx, gx, …`).  
- «^-формат» — аналогично, но с `c^, g^, …`.  

На финальном шаге (при выводе текста) приложение автоматически выполняет нужную замену.  

### 2.8 Просмотр и скачивание результата
После нажатия **«Отправить»** внизу страницы появляется:
1. **Предварительный просмотр**.
   - Для HTML-вывода появляются вкладки («HTML-просмотр», «Результат замены (HTML-код)»).  
   - Для не-HTML появляется вкладка «Текст результата замены».  
   - Если текст огромный, приложение может показать только часть строк (начальные и конечные), а остальное обозначить `...` (для экономии места).  
2. **Кнопка «Скачать результат замены»**.  
   - Можно выгрузить готовый файл (например, `置換結果.html`) с кодировкой UTF-8.  

### 2.9 Ссылка на GitHub
В самом низу – ссылка на репозиторий GitHub, где лежит исходный код этого приложения.

---

## 3. Вторая страница: «Генератор JSON-файлов для замены…» (`JГенератор JSON-файлов…py`)

Чтобы перейти к этой странице:
1. В левом верхнем углу (панель Streamlit) есть выпадающее меню «Select page…». Выберите страницу **«Генератор JSON-файлов…»**.
2. Откроется новый интерфейс, позволяющий **собрать свой JSON** с правилами замены для эсперанто-текста.

Главные шаги работы на этой странице:

### 3.1 Загрузка (или выбор по умолчанию) CSV-файла
В разделе **«Шаг 1: Подготовить CSV-файл»** вы решаете, использовать ли:
- **«Загрузить файл»**: Выберите свой `.csv`, где в первой колонке — эсперанто-корень, во второй — перевод/иероглиф.
- **«Использовать по умолчанию»**: Тогда возьмётся стандартный CSV (`Корни эсперанто – список с русским переводом и руби.csv`).

CSV может содержать 2 столбца:
- Столбец A: `E_root` (корень / слово на эсперанто)  
- Столбец B: перевод, который пойдёт в руби или замену.  

Пример:  
```
amiko, друг
domo, дом
kato, кот
... и т.д.
```

### 3.2 Загрузка (или выбор по умолчанию) JSON-файлов (дополнительные настройки)
В **«Шаг 2»** можно добавить свои кастомные JSON:
1. **JSON-файл (правила разбора корней эсперанто)** – например, как разбирать составные слова, учитывать ли суффиксы и т. д.  
2. **JSON-файл (добавление собственных строк замены)** – более тонкая настройка для конкретных слов.  

Если у вас нет специальных требований, можно оставить «Использовать по умолчанию».

### 3.3 Настройка параллельной обработки
Как и в `main.py`, есть блок **«Расширенные настройки (параллельная обработка)»**, где можно включить/выключить multiprocessing и указать количество процессов. Если CSV содержит тысячи строк, это ускорит генерацию.

### 3.4 Генерация «итогового JSON-файла для замены»
Внизу страница предлагает кнопку **«Создать JSON-файл для замены»**. Нажав её, вы запускаете крупный процесс, который:
1. Считывает все загруженные данные (CSV + JSON для разбора корней + второй JSON и т.п.).
2. Формирует три основных списка правил замены:
   - **`"全域替换用のリスト(…)"`**  
   - **`"二文字词根替换用のリスト(…)"`**  
   - **`"局部文字替换用のリスト(…)"`**  
3. Сливает их в один большой словарь формата:
   ```json
   {
     "全域替换用のリスト(列表)型配列(replacements_final_list)": [...],
     "二文字词根替换用のリスト(列表)型配列(replacements_list_for_2char)": [...],
     "局部文字替换用のリスト(列表)型配列(replacements_list_for_localized_string)": [...]
   }
   ```
4. Предлагает скачать этот объединённый JSON (размер может быть 50MB и более, в зависимости от объёма данных).

Получившийся JSON можно потом использовать на **главной странице** (в `main.py`), выбрав «Загрузить» и указав этот файл. Тогда ваше приложение будет работать уже с вашими уникальными правилами.

---

## 4. Модули `esp_text_replacement_module.py` и `esp_replacement_json_make_module.py`
Данные файлы содержат «внутренние» функции и классы, которые:
- Выполняют низкоуровневую замену (safe_replace и другие).  
- Реализуют разные виды преобразования эсперанто-символов (`x->ĉ`, `^->ĉ`, обратно и т.д.).  
- Поддерживают логику «руби-выравнивания»: например, если руби-часть длиннее основной, уменьшаем шрифт и т. п.  
- Осуществляют проверку на коллизии при заменах (напр. если `%xxx%` — нужно пропустить).  
- Включают вспомогательные функции для параллельной обработки (multiprocessing).  

**Прямого взаимодействия** с ними в GUI обычно нет: пользователь просто нажимает кнопки в `main.py` или на странице генерации JSON, а внутри кода «модули» делают всю “черновую” работу.

---

## 5. Советы и дополнительные возможности

1. **Использование `%...%`**  
   Если какой-то фрагмент текста не нужно изменять/заменять вообще, оберните его в символы `%`.  
   Пример:  
   ```
   Jen mia teksto. Sed %ĉi tiu parto% останется без изменений!
   ```
   В результате всё внутри `%...%` пропустится.

2. **Использование `@...@`**  
   Если наоборот, вам нужно *локально* применить специальные правила (второй список из JSON), обрамите фрагмент `@`.  
   ```
   Ĉi tio @tre speciala vorto@ estos обработано по особым локальным правилам.
   ```
3. **Параллельная обработка**  
   - Если ваш текст имеет сотни тысяч символов и множество корней, поставьте 2–4 процесса (зависит от CPU).  
   - На слабой машине со скромным объёмом данных можно оставить 1 процесс (или выключить).  

4. **Форматы вывода**  
   - При выборе **HTML**-вариантов можно затем отобразить результат в браузере: теги `<ruby>…<rt>…</rt></ruby>` сделают наглядные надстрочные подписи (руби).  
   - «(Скобки)» – формат для более простых случаев, когда `<ruby>` не требуется.

5. **Контроль за «двухсимвольными корнями»**  
   Внутри JSON-преобразования есть особые правила для корней длиной в 2 буквы: они отделяются символом `$` или другим. Это делает замену более точной, чтобы избегать ложных срабатываний. Если вы хотите глубоко кастомизировать суффиксы/префиксы – изучите `esp_replacement_json_make_module.py` и логику формирования `replacements_list_for_2char`.

6. **Установка размеров и цвета руби**  
   В режиме `HTML格式_Ruby文字_大小调整` есть специальный `<style>` (CSS), который динамически выбирает класс `S_S`, `M_M`, `XXL_L` и т. д. – всё это вы можете настроить при желании в коде: например, изменить `--ruby-font-size`, `margin-top` или `color`.

---

## 6. Заключение
Это приложение даёт гибкую систему:
- **На главной странице** (`main.py`) вы выполняете конечную замену/обработку своих эсперанто-текстов, используя готовый (или свой) JSON.  
- **На второй странице** (`pages/JГенератор JSON-файлов…`) вы можете собрать собственный «огромный JSON» правил, опираясь на CSV-файлы и дополнительные JSON-настройки.  

Так вы сможете автоматически проставлять «иероглифы + руби» (или русский перевод + руби) на основе корней эсперанто, пользуясь удобным веб-интерфейсом.  

**Надеемся, что данное пошаговое руководство поможет русскоязычным пользователям быстро освоить все функции приложения. Удачи и приятной работы!**
