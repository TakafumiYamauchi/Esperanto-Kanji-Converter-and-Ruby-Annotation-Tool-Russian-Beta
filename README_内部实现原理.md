# Esperanto-Kanji-Converter-and-Ruby-Annotation-Tool-Russian

Ниже приведено детальное описание **внутреннего механизма** и **архитектуры** приложения на Streamlit (файлы `main.py`, «JSON File Generation Page…», `esp_text_replacement_module.py` и `esp_replacement_json_make_module.py`). Предполагается, что читатель уже **частично знаком** с функционалом Graphical User Interface (GUI) приложения, но хочет глубже разобраться, **как** всё устроено «под капотом». Материал ориентирован на **программистов среднего уровня**, владеющих Python и Streamlit.  

---

## 1. Общий обзор структуры и ролей файлов

### 1.1 `main.py`
- **Главный файл**, с которого обычно начинается запуск (`streamlit run main.py`).  
- Содержит основной код, отвечающий за:
  - Загрузку (или выбор по умолчанию) основного JSON, в котором описаны правила замены.  
  - Подготовку интерфейса: поля ввода текста, выбор формата, радиокнопки, чекбоксы для параллельной обработки и т. п.  
  - Организацию процессов чтения и обработки текста (включая параллельные).  
  - Финальный вывод (превью, вкладки, кнопка скачивания результата).  

### 1.2 «JSON File Generation Page…» (в коде: `JГенератор JSON-файлов для замены (иероглифов) в эсперанто-тексте.py`)
- Располагается в папке `pages/` (типичная особенность Streamlit).  
- Обеспечивает **генерацию** большого единого JSON-файла, который потом можно использовать в `main.py`.  
- Логика:
  1. Загрузка/выбор CSV с корнями эсперанто и переводами (и/или иероглифами).  
  2. Дополнительно — загрузка/выбор кастомных JSON с пользовательскими правилами разбора корней и специфическими заменами.  
  3. Обработка (при желании — в несколько процессов) и формирование **трёх основных списков**:
     - «Глобальная» замена  
     - «Локальная» замена  
     - «Замена для двухсимвольных корней»  
  4. Слияние их в единый JSON (примерно 50MB и более).  

### 1.3 `esp_text_replacement_module.py`
- Модуль, импортируемый `main.py`.  
- Хранит ключевые функции для обработки эсперанто-текста:
  - Функции конвертации (например, `cx` → `ĉ`), а также обратно (`ĉ` → `c^` и т. п.).  
  - Функция **`orchestrate_comprehensive_esperanto_text_replacement(...)`**, которая на практике делает всё: применяет правила «пропуска» фрагментов `%...%`, «локальной» замены `@...@`, «глобальной» замены, учитывая загруженный JSON.  
  - Код для параллельной обработки (разбивка текста на строки и распределение по процессам).  
  - Функция для генерации HTML-руби-заголовка (при формате с `<ruby>`).  

### 1.4 `esp_replacement_json_make_module.py`
- Модуль, импортируемый **второй страницей** (где генерируют JSON).  
- Аналогично содержит общие функции:
  - Для конвертации символов в эсперанто-формат.  
  - Для обработки строк (например, определения ширины символов в Arial16, чтобы умно подбирать размер `rt`-элемента в HTML).  
  - Функции, которые собирают и комбинируют готовые правила замены, учитывая CSV, пользовательские JSON и т. д.  
  - Логику параллельной генерации (когда у вас тысячи строк CSV).  

---

## 2. Архитектура кода и взаимодействие модулей

Ниже описывается **способ** взаимодействия, начиная с этапа генерации JSON и заканчивая процессом замены в `main.py`.

### 2.1 Генерация JSON-файла (вторая страница)

1. **Пользователь** загружает CSV, где, например, в 1-й колонке — эсперанто-корень, во 2-й — перевод/иероглиф.  
2. Загружает (по желанию) кастомные JSON-файлы, в которых описаны особые правила разбора слов:  
   - «Как разбирать сложносоставные слова», «Какие суффиксы/префиксы считать отдельными морфемами» и т. п.  
   - «Какие слова нужно исключить/переопределить».  
3. Функции из `esp_replacement_json_make_module.py` (например, `parallel_build_pre_replacements_dict`) обрабатывают тысячи корней из CSV:  
   - Для каждого корня подбирают нужную форму (HTML с `<ruby>...<rt>...</rt></ruby>` или скобочный вид), исходя из выбранного **формата** (в selectbox).  
   - Учитывают приоритеты (более длинные корни заменяются раньше, чтобы избежать коллизий).  
   - Делают несколько проходов, чтобы сформировать **три отдельных списка**:  
     1. **Глобальные** замены (`replacements_final_list`)  
     2. **Локальные** замены для `@...@`  
     3. **Двухбуквенные** корни (и их склонения), которые tricky при поиске (`replacements_list_for_2char`).  
4. Всё собирается в единый словарь:  
   ```python
   combined_data = {
       "全域替换用のリスト(列表)型配列(replacements_final_list)": [...],
       "二文字词根替换用のリスト(列表)型配列(replacements_list_for_2char)": [...],
       "局部文字替换用のリスト(列表)型配列(replacements_list_for_localized_string)": [...]
   }
   ```
   И этот словарь сериализуют в JSON (часто очень большой).  
5. **Кнопка Download**: вы скачиваете готовый `Итоговый_список_замены(слияние_3_JSON).json`.  

Таким образом, во втором шаге приложения вы **готовите нужные правила**.  

### 2.2 Загрузка и применение JSON в `main.py`

1. Пользователь запускает **`main.py`** (или в Streamlit-навигации переходит на главную страницу).  
2. В верхней части приложения — радиокнопки: «Использовать JSON по умолчанию» или «Загрузить».  
   - Если «Загрузить», то вы берёте тот `Итоговый_список_замены.json`, который только что сформировали.  
3. Далее `main.py` (через функцию `load_replacements_lists`) извлекает из JSON три списка правил.  
   - Сохраняются в переменных:
     ```python
     replacements_final_list,
     replacements_list_for_localized_string,
     replacements_list_for_2char
     ```
4. Пользователь вводит/загружает **текст эсперанто**, выбирает формат вывода, решает, включать ли параллельную обработку и т. п.  
5. При нажатии «Отправить» **код** `main.py` вызывает главную функцию:
   ```python
   processed_text = orchestrate_comprehensive_esperanto_text_replacement(
       text=...,
       placeholders_for_skipping_replacements=...,
       replacements_list_for_localized_string=...,
       placeholders_for_localized_replacement=...,
       replacements_final_list=...,
       replacements_list_for_2char=...,
       format_type=...
   )
   ```
   или, при включённой параллельности, — обёртку `parallel_process()`, которая внутри всё равно вызывает `orchestrate_comprehensive_esperanto_text_replacement()`.  

#### 2.2.1 Что делает `orchestrate_comprehensive_esperanto_text_replacement()`?
- Сначала приводит все эсперанто-символы к **“circumflex-формату”** (например, `cx`, `c^` → `ĉ`).  
- Идёт поиск **«skip-областей»** `%...%`. Всё, что внутри таких областей, оборачивается во временные placeholder-строки, чтобы туда **не применять** замены.  
- Идёт поиск **«локальных областей»** `@...@`. Текст внутри них заменяется по **второму** списку (локальные правила), а тоже временно сворачивается в placeholder.  
- Применяется **глобальная** замена (первый список) построчно или целиком. При этом каждое «старое слово» заменяется на placeholder, который потом раскрывается как `<ruby>...<rt>...</rt></ruby>` или `( ...)`.  
- Отдельная логика для «двухсимвольных корней» (третий список) — иногда делается в два прохода.  
- После всех замен **возвращают** на место временные placeholder (там, где %...% или @...@).  
- Если формат вывода — HTML с руби, добавляют `<br>`, меняют пробелы на `&nbsp;` и т. д.  
- Возвращается **итоговый** текст (уже со вставленными иероглифами и руби).  

#### 2.2.2 Параллельная обработка
- Если пользователь включил опцию (checkbox) и указал `num_processes`, текст **разбивается** по строкам, разделяется на ~равные «куски» и параллельно обрабатывается в пуле процессов (`multiprocessing.Pool`).  
- Каждому процессу передаётся кусок строк, он вызывает `orchestrate_comprehensive_esperanto_text_replacement()` для этого куска.  
- Потом результаты склеиваются, и мы получаем единый текст.  

---

## 3. Логика placeholders для пропуска и локальной замены

В коде вы увидите несколько текстовых файлов из папки `./Appの运行に使用する各类文件/…`, например:
- `占位符(placeholders)_%1854%-%4934%_文字列替换skip用.txt`  
- `占位符(placeholders)_@5134@-@9728@_局部文字列替换结果捕捉用.txt`  

Это готовые **последовательности** “уникальных строчек”, применяемые как служебные placeholder. Смысл:
- Когда функция находит `"%xxx%"`, она **берёт** первую свободную строку из `占位符(...skip用).txt` и заменяет `"%xxx%"` → `PH_ABC_1` (к примеру).  
- Дальше в процессе замены никакие правила к `PH_ABC_1` не применяются.  
- В конце снова `PH_ABC_1` меняют на исходный `%xxx%`.  

Аналогично для `@...@`, только используется другой файл placeholders. Таким образом, **код** не «ломается» при сложных заменах и сохраняет нужные фрагменты в целости.

---

## 4. Форматы вывода: как формируются `<ruby>…</ruby>` и скобки

В `esp_text_replacement_module.py` и `esp_replacement_json_make_module.py` есть функция вроде:

```python
def output_format(main_text, ruby_content, format_type, char_widths_dict):
    # ...
    if format_type == 'HTML格式_Ruby文字_大小调整':
        # Генерация <ruby>main_text<rt class="...">ruby_content</rt></ruby>
        # + логика, рассчитывающая размер шрифта <rt> на основе ширины
        # ...
    elif format_type == 'HTML格式':
        return f'<ruby>{main_text}<rt>{ruby_content}</rt></ruby>'
    elif format_type == '括弧(号)格式':
        return f'{main_text}({ruby_content})'
    # ...
```

Смысл: при построении правила замены каждая пара (оригинал, перевод) может оформляться либо **HTML-руби**, либо `(...)`, либо просто переводом. Это задаётся `format_type` (из `selectbox` в приложении).  

При `HTML格式_Ruby文字_大小调整` есть дополнительная логика — приложение **смотрит**, какую «визуальную ширину» имеет `main_text` и `ruby_content`, и в зависимости от ratio выбирает размер класса `rt class="L_L"`, `S_S`, `XL_L` и т. д. (в CSS описано, на сколько уменьшать/увеличивать руби).  

---

## 5. Дополнительные особенности кода

- **Обработка суффиксов/префиксов** (особенно двухбуквенных). Есть блоки кода, в которых прописаны списки `suffix_2char_roots`, `prefix_2char_roots`, `standalone_2char_roots`. Это нужно, чтобы «am», «ig», «ebl», «re» и т. п. корректно находились/заменялись, не вызывая коллизии (пример: не путать «am» в слове «amiko» и суффикс «-am-»).  
- **Очистка повторяющегося руби**: есть функции типа `remove_redundant_ruby_if_identical()`, которые удаляют `"<ruby>xxx<rt>xxx</rt></ruby>"`, если `xxx` одинаковые (чтобы не было дублирования).  
- **CAP (capitalize) vs. UPPER**: при формировании правила к одному и тому же корню бывает нужно учесть, что в тексте может встретиться слово с заглавной буквы (в начале предложения) или все заглавные. Тогда программа, кроме `old`, также генерирует `old.capitalize()` и `old.upper()` в том же «глобальном списке».  

---

## 6. Выводы

Таким образом, **приложение** строится вокруг двух основных этапов:

1. **Генерация** большого JSON (страница «JSON File Generation Page…»):  
   - Считывание CSV и дополнительных JSON  
   - Подготовка сложных правил для эсперанто-корней (включая суффиксы, двусимвольные корни, особые разборы).  
   - Итог — скачивание объединённого JSON.  

2. **Замена** текста (главная страница `main.py`):  
   - Загрузка полученного JSON  
   - Ввод исходного текста (вручную или из файла)  
   - Применение правил (учитывая пропуск `%...%`, локальные `@...@`, глобальные замены, суффиксы)  
   - Выдача результата в выбранном формате (HTML/скобки/и т. д.) + возможность скачать.  

При этом **на уровне кода** основная «магия» сосредоточена в двух вспомогательных модулях:  
- `esp_text_replacement_module.py` (применение замен, placeholders, параллельная обработка)  
- `esp_replacement_json_make_module.py` (генерация правил для JSON, учёт разных форм слов, морфем).  

**Принципы, на которые стоит обратить внимание**:
1. **Placeholder-подход** к защите фрагментов `%...%` и «точечной» замене `@...@`.  
2. **Системный учёт** разных случаев для эсперанто-окончаний (as/is/os, суффиксов, сложных слов).  
3. **Гибкая система** форматирования (HTML руби, скобки, простой текст).  
4. **Параллельная обработка**: большие массивы строк для ускорения.  

Для **русскоязычного среднего программиста**, знакомого с Python, код относительно легко расширить или адаптировать:
- Добавить свои списки суффиксов/префиксов,  
- Подключить другую разметку вместо `<ruby>`,  
- Сменить правила сортировки замен и т. д.  

Главное — сохранять **логику**: сначала надо сгенерировать корректный набор **replacements**, затем в `main.py` импортировать и вызвать `orchestrate_comprehensive_esperanto_text_replacement(...)` или через `parallel_process(...)`.

---

### Заключение
Этот «двухстраничный» Streamlit-подход оказался удобным:
- на одной странице мы делаем подготовку (создание JSON-правил),
- на другой — конечное применение.  

В результате:
- Пользователь без глубоких знаний может ограничиться нажатием кнопок и загрузкой файлов,  
- А **программист** может легко дополнять/менять модули (`esp_text_replacement_module.py`, `esp_replacement_json_make_module.py`), чтобы тонко настраивать морфологический анализ и форматы руби-вывода.

**Надеемся**, что теперь вы **глубже** понимаете внутренний механизм приложения и сможете эффективно им пользоваться или модифицировать под нужные задачи!
